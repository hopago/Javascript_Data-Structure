/** 시간복잡도
 
 [1, 2, 3, 4, 5] - O(1)
 특정 작업량을 찾는 것을 표기 - n
 표기법 O(n), Θ(1) - 최선의 경우, 한 번에 찾음

 -빅5 노테이션 순서
 O(1)
 O(log n)
 O(n)
 O(n log n)
 O(n**2)
 O(n**3)
 O(2**n) - 지양
 O(n!) - 지양

 -예제: 업다운 게임
 [1, ..., 50, ... 100]
 1. 50을 먼저 부른다
 2. 25를 부른다
 3. 37을 부른다
 4. 37~50 || 27~50을 부른다
 5. 중간값을 소거해가며 찾아나간다
 *반씩 쪼개서 사라지는 알고리즘 O(log n), 하나씩 찾아가는 것 O(n)*

 n을 코드상에서 판별하는 법 - for(let i = 0; i < array.length; i++) - O(n)
 for (let j=0; j<array.length; j++) - O(n ** 2)
 만약 i가 하나씩 더하는 것이 아닌 두 배씩 늘어난다 - O(log n)

 */

 /** 공간복잡도
  * 메모리나 하드디스크가 늘어남에 따라 크게 따지지는 않는다
  * 대부분의 알고리즘은 자기 자신의 복제본을 만드는 것에서 끝나기 때문에 실무상 공간복잡도는 O(n) || O(2n)
  * O(n) || O(2n) 이라면 O(n)이 작업 속도가 2배 빠르다
  * 앞에 계수가 붙은 정도는 같다라고 본다
  * 지수가 다르다면 차원이 다르다고 본다
  * 알고리즘은 숫자가 <충분히 클 때> 성능이 좋다
  */